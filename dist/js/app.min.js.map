{"mappings":"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","sources":["scripts/class_Modal.js","scripts/custom_events.js","scripts/class_Request.js","scripts/helper_ajax.js","scripts/libs/mustache.js","scripts/helper_template.js","node_modules/@swc/helpers/src/_define_property.js","scripts/class_Bindable.js","node_modules/@swc/helpers/src/_object_spread.js","scripts/helper_binding.js","scripts/helper_ui.js","scripts/app.js","scripts/class_Template.js","scripts/class_Benchmark.js"],"sourcesContent":["/**\r\n * - A class representing a modal window. This is an alternative to using \r\n * window.alert() or window.confirm() to provide a better, more consistent\r\n * browsing experience for users. \r\n */\r\nexport class Modal {\r\n    constructor(content) {\r\n\r\n        let modalWindow = document.createElement(\"div\");\r\n\r\n        this.element = modalWindow;\r\n\r\n        this.content = content;\r\n\r\n        this.callbacks = {\r\n            close: () => { this.element.remove(); }\r\n        };\r\n\r\n        modalWindow.id = \"ModalWrapper\";\r\n\r\n        modalWindow.dataset.mclick = \"close\";\r\n\r\n        modalWindow.addEventListener(\"click\", (e, z) => {\r\n            let action = e.target?.dataset?.mclick;\r\n\r\n            this.callbacks[action]?.(e.target);\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * - Closes the active modal window.\r\n     */\r\n    close() {\r\n        this.element.remove();\r\n    }\r\n\r\n    /**\r\n     * - Render the modal window to the page. \r\n     */\r\n    show() {\r\n\r\n        let modalContent = `<div id=\"ModalContent\">${this.content}</div>`;\r\n\r\n        this.element.innerHTML = modalContent;\r\n\r\n        document.body.appendChild(this.element);\r\n    }\r\n\r\n    /**\r\n     * This implementation simply uses an alternate template for the content.\r\n     */\r\n    alert() {\r\n        let template = `<h1>Alert</h1><hr>\r\n                            <div id=\"Alert\">${this.content}<hr>\r\n                            <button data-mclick=\"close\" id=\"CloseModal\">Okay</button>\r\n                            </div>`;\r\n\r\n        this.content = template;\r\n\r\n        this.show();\r\n    }\r\n\r\n    /**\r\n     * This implementation includes warning text and returns false. \r\n     */\r\n    warn() {\r\n        let template = `<h1>Warning</h1><hr>\r\n                        <div id=\"Warning\">${this.content}<hr>\r\n                        <button data-mclick=\"close\" id=\"CloseModal\">Okay</button>\r\n                        </div>`;\r\n\r\n        this.content = template;\r\n\r\n        this.show();\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * - This implementation creates a confirm/decline dialogue and invokes callbacks for each. \r\n     * @param {function} ifYes \r\n     * @param {function} ifNo \r\n     * @returns - a promise object\r\n     */\r\n    async confirm() {\r\n\r\n        const self = this;\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            try {\r\n                let template = `<h1>Confirm</h1><hr>\r\n                                <div id=\"Confirm\">${this.content}<hr>\r\n                                    <button data-mclick=\"confirmYes\">Yes</button>\r\n                                    <button data-mclick=\"confirmNo\">No</button>\r\n                                </div>`;\r\n\r\n                self.content = template;\r\n\r\n                self.callbacks.confirmYes = () => {\r\n                    try {\r\n                        self.close();\r\n                        resolve(true);\r\n                    } catch (error) {\r\n                        reject(error);\r\n                    }\r\n                };\r\n\r\n                self.callbacks.confirmNo = () => {\r\n                    try {\r\n                        self.close();\r\n                        resolve(false);\r\n                    } catch (error) {\r\n                        reject(error);\r\n                    }\r\n                };\r\n\r\n                self.show();\r\n            } catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This implementation provides text input for the user and then sends it to the provided callback for use. \r\n     * @returns - a promise object\r\n     */\r\n    async textInput() {\r\n\r\n        const self = this;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                let template = `<h2>Input Text</h2>\r\n                                <textarea id=\"TextInput\" class=\"modal-input\">Write Text Here</textarea><hr>\r\n                                <button data-mclick=\"processTextInput\">Continue</button>`;\r\n\r\n                self.content = template;\r\n\r\n                self.callbacks.processTextInput = (e) => {\r\n\r\n                    try {\r\n                        let text = document.getElementById(\"TextInput\").value;\r\n\r\n                        self.close();\r\n\r\n                        resolve(text);\r\n                    } catch (error) {\r\n                        reject(error);\r\n                    }\r\n                };\r\n\r\n                this.show();\r\n\r\n            } catch (error) {\r\n                reject(error);\r\n            }\r\n\r\n        });\r\n\r\n\r\n    }\r\n}\r\n","import { Modal } from \"./class_Modal.js\";\r\n\r\nexport const events = {\r\n    click: {},\r\n    change: {},\r\n    keyup: {},\r\n    actions: {}\r\n};\r\n\r\n/**\r\n * - Trigger an event (like jQuery's $().trigger)\r\n * @param {string} name \r\n * @param {object} data \r\n * @param {HTMLElement} element \r\n */\r\nconst triggerEvent = (name, data, element) => {\r\n    let eventData = { detail: data };\r\n    let event = new CustomEvent(name, eventData);\r\n\r\n    element = element ?? document;\r\n\r\n    element.dispatchEvent?.(event, eventData);\r\n};\r\n\r\n/**\r\n * - Trigger an event on all elements that match a query. \r\n * @param {string} name \r\n * @param {object} data \r\n * @param {string} selector - Query that will return multiple elements\r\n */\r\nconst triggerEventAll = (name, data, selector) => {\r\n\r\n    try {\r\n        let elements = document.querySelectorAll(selector);\r\n\r\n        elements.forEach((item) => {\r\n            triggerEvent(name, data, item);\r\n        });\r\n\r\n    } catch (er) {\r\n        let message = new Modal(\"Error!\").show();\r\n    }\r\n};\r\n","/**\r\n * Class for making AJAX (XHR) requests\r\n */\r\nexport class Request {\r\n    /**\r\n     * \r\n     * @param {string} requestType - POST or GET\r\n     * @param {string} returnType  - Data expected on return (JSON/HTML)\r\n     * @param {string} url - URL for Request\r\n     * @param {object} data - Data to Send\r\n     */\r\n    constructor(requestType, returnType, url, data) {\r\n        if (typeof requestType === \"object\" && arguments.length == 1) {\r\n            Object.assign(this, requestType);\r\n        } else {\r\n            this.requestType = requestType ?? \"GET\";\r\n            this.returnType = returnType ?? \"JSON\";\r\n            this.url = url ?? \"\";\r\n            this.data = data ?? {};\r\n        }\r\n        this.thenHandler = () => { };\r\n        this.catchHandler = () => { };\r\n        this.xhr = new XMLHttpRequest();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * - Set the URL for a GET request.\r\n     * @param {string} url \r\n     * @returns a self reference for chaining.\r\n     */\r\n    from(url) {\r\n        this.url = url;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * - Set the URL for a POST request.\r\n     * @param {string} url \r\n     * @returns a self reference for chaining.\r\n     */\r\n    to(url) {\r\n        this.from(url);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the data to send in a request (POST or GET)\r\n     * Key-value-pairs are converted to URL params for GET requests.\r\n     * @param {object} data \r\n     * @returns a self reference for chaining.\r\n     */\r\n    using(data) {\r\n        this.data = data;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Deprecated - a callback for when the request completes. Use send() instead. \r\n     * @param {function} callback \r\n     * @returns  a self reference for chaining.\r\n     */\r\n    then(callback) {\r\n        this.thenHandler = callback;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Deprecated - a callback for catching request errors. Use send() instead. \r\n     * @param {function} callback \r\n     * @returns a self reference for chaining.\r\n     */\r\n    catch(callback) {\r\n        this.catchHandler = callback;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WARNING: This function is \"private\" & may return unexpected results. \r\n     * This determines whether to run the result through JSON.parse() to convert\r\n     * JSON back into normal JavaScript. \r\n     * @param {object} data \r\n     * @returns \r\n     */\r\n    _processReturn(data) {\r\n        if (this.returnType == \"JSON\") {\r\n            return JSON.parse(data);\r\n        }\r\n\r\n        if (this.returnType == \"HTML\") {\r\n            return data;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * WARNING: This function is \"private\" & may return unexpected results. \r\n     * This function formates the headers and/or data for POST/GET requests. \r\n     */\r\n    _prepHeaders() {\r\n        if (this.requestType === \"POST\") {\r\n            this.xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\r\n        }\r\n        if (this.requestType === \"GET\") {\r\n            var str = Object.keys(this.data).map(key => `${key}=${this.data[key]}`).join(\"&\");\r\n            this.url = `${this.url}?${str}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute the XHR Request\r\n     * @returns A promise object with the result.\r\n     */\r\n    async send() {\r\n        this._prepHeaders();\r\n\r\n        return new Promise((resolve, reject) => {\r\n            \r\n            const Request = this;\r\n\r\n            Request.xhr.open(Request.requestType, Request.url, true);\r\n\r\n            Request.xhr.onload = function () {\r\n                if (this.status >= 200 && this.status < 400) {\r\n                    var data = Request._processReturn(this.response);\r\n                    resolve(data);\r\n                }\r\n                reject(\"Moderate Error\");\r\n            };\r\n            Request.xhr.onerror = function () {\r\n                reject(\"Serious Error\");\r\n            };\r\n            // INITIATE AJAX REQUEST\r\n            Request.xhr.send(Request.data);\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deprecated - I recommend using the promisified version, send(). \r\n     * @returns a reference to the request instance. \r\n     */\r\n    now() {\r\n        this._prepHeaders();\r\n\r\n        const promise = new Promise((resolve, reject) => {\r\n            const Request = this;\r\n\r\n            Request.xhr.open(Request.requestType, Request.url, true);\r\n\r\n            Request.xhr.onload = function () {\r\n                if (this.status >= 200 && this.status < 400) {\r\n                    var data = Request._processReturn(this.response);\r\n                    resolve(data);\r\n                }\r\n                reject(\"Moderate Error\");\r\n            };\r\n            Request.xhr.onerror = function () {\r\n                reject(\"Serious Error\");\r\n            };\r\n            // INITIATE AJAX REQUEST\r\n            Request.xhr.send(Request.data);\r\n        })\r\n            .then(this.thenHandler)\r\n            .catch(this.catchHandler);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * A request preset to \"GET\"\r\n */\r\nexport class GET extends Request {\r\n    constructor(returnType) {\r\n        super(\"GET\", returnType, null, null);\r\n    }\r\n}\r\n\r\n/**\r\n * A request preset to \"POST\"\r\n */\r\nexport class POST extends Request {\r\n    constructor(data) {\r\n        super(\"POST\", null, null, data);\r\n    }\r\n}\r\n","import { GET, POST } from './class_Request.js';\r\n\r\n/**\r\n * - Deprecated, I recommend using the promisified version. \r\n * @param {string} url \r\n * @param {function} callback \r\n * @param {function} onError \r\n */\r\nexport const getJSON = (url, callback, onError) => {\r\n    let request = new GET(\"JSON\").from(url).then(callback).catch(onError);\r\n    request.now();\r\n}\r\n\r\n/**\r\n * - Deprecated, I recommend using the promisified version. \r\n * @param {string} url \r\n * @param {function} callback \r\n * @param {function} onError \r\n */\r\nexport const getHTML = (url, callback, onError) => {\r\n    let request = new GET(\"HTML\").from(url).then(callback).catch(onError);\r\n    request.now();\r\n};\r\n\r\n/**\r\n * - Deprecated, I recommend using the promisified version. \r\n * @param {string} url \r\n * @param {object} data\r\n * @param {function} callback \r\n * @param {function} onError \r\n */\r\nexport const postData = (url, data, callback, onError) => {\r\n    let request = new POST(data).to(url).then(callback).catch(onError);\r\n    request.now();\r\n};\r\n\r\n/**\r\n * - Post data asynchronously to a URL. \r\n * @param {string} url \r\n * @param {object} data \r\n * @returns - A promise object with the result \r\n */\r\nexport const postDataPromise = (url, data) => {\r\n    let request = new POST(data).to(url);\r\n    return request.send();\r\n};\r\n\r\n/**\r\n * - Get HTML text from a URL\r\n * @param {string} url \r\n * @returns - A promise object with the result\r\n */\r\nexport const getHtmlPromise = (url) => {\r\n    let request = new GET(\"HTML\").from(url);\r\n    return request.send();\r\n};\r\n\r\n/**\r\n * - Get JSON text from a URL\r\n * @param {string} url \r\n * @returns - A promise object with the result\r\n */\r\nexport const getJsonPromise = (url) => {\r\n    let request = new GET(\"JSON\").from(url);\r\n\r\n    return request.send();\r\n};\r\n\r\n\r\n","/*!\r\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\r\n * http://github.com/janl/mustache.js\r\n */\r\n\r\nvar objectToString = Object.prototype.toString;\r\nvar isArray = Array.isArray || function isArrayPolyfill (object) {\r\n  return objectToString.call(object) === '[object Array]';\r\n};\r\n\r\nfunction isFunction (object) {\r\n  return typeof object === 'function';\r\n}\r\n\r\n/**\r\n * More correct typeof string handling array\r\n * which normally returns typeof 'object'\r\n */\r\nfunction typeStr (obj) {\r\n  return isArray(obj) ? 'array' : typeof obj;\r\n}\r\n\r\nfunction escapeRegExp (string) {\r\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\r\n}\r\n\r\n/**\r\n * Null safe way of checking whether or not an object,\r\n * including its prototype, has a given property\r\n */\r\nfunction hasProperty (obj, propName) {\r\n  return obj != null && typeof obj === 'object' && (propName in obj);\r\n}\r\n\r\n/**\r\n * Safe way of detecting whether or not the given thing is a primitive and\r\n * whether it has the given property\r\n */\r\nfunction primitiveHasOwnProperty (primitive, propName) {\r\n  return (\r\n    primitive != null\r\n    && typeof primitive !== 'object'\r\n    && primitive.hasOwnProperty\r\n    && primitive.hasOwnProperty(propName)\r\n  );\r\n}\r\n\r\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\r\n// See https://github.com/janl/mustache.js/issues/189\r\nvar regExpTest = RegExp.prototype.test;\r\nfunction testRegExp (re, string) {\r\n  return regExpTest.call(re, string);\r\n}\r\n\r\nvar nonSpaceRe = /\\S/;\r\nfunction isWhitespace (string) {\r\n  return !testRegExp(nonSpaceRe, string);\r\n}\r\n\r\nvar entityMap = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;',\r\n  '\"': '&quot;',\r\n  \"'\": '&#39;',\r\n  '/': '&#x2F;',\r\n  '`': '&#x60;',\r\n  '=': '&#x3D;'\r\n};\r\n\r\nfunction escapeHtml (string) {\r\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\r\n    return entityMap[s];\r\n  });\r\n}\r\n\r\nvar whiteRe = /\\s*/;\r\nvar spaceRe = /\\s+/;\r\nvar equalsRe = /\\s*=/;\r\nvar curlyRe = /\\s*\\}/;\r\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\r\n\r\n/**\r\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\r\n * argument is given here it must be an array with two string values: the\r\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\r\n * course, the default is to use mustaches (i.e. mustache.tags).\r\n *\r\n * A token is an array with at least 4 elements. The first element is the\r\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\r\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\r\n * all text that appears outside a symbol this element is \"text\".\r\n *\r\n * The second element of a token is its \"value\". For mustache tags this is\r\n * whatever else was inside the tag besides the opening symbol. For text tokens\r\n * this is the text itself.\r\n *\r\n * The third and fourth elements of the token are the start and end indices,\r\n * respectively, of the token in the original template.\r\n *\r\n * Tokens that are the root node of a subtree contain two more elements: 1) an\r\n * array of tokens in the subtree and 2) the index in the original template at\r\n * which the closing tag for that section begins.\r\n *\r\n * Tokens for partials also contain two more elements: 1) a string value of\r\n * indendation prior to that tag and 2) the index of that tag on that line -\r\n * eg a value of 2 indicates the partial is the third tag on this line.\r\n */\r\nfunction parseTemplate (template, tags) {\r\n  if (!template)\r\n    return [];\r\n  var lineHasNonSpace = false;\r\n  var sections = [];     // Stack to hold section tokens\r\n  var tokens = [];       // Buffer to hold the tokens\r\n  var spaces = [];       // Indices of whitespace tokens on the current line\r\n  var hasTag = false;    // Is there a {{tag}} on the current line?\r\n  var nonSpace = false;  // Is there a non-space char on the current line?\r\n  var indentation = '';  // Tracks indentation for tags that use it\r\n  var tagIndex = 0;      // Stores a count of number of tags encountered on a line\r\n\r\n  // Strips all whitespace tokens array for the current line\r\n  // if there was a {{#tag}} on it and otherwise only space.\r\n  function stripSpace () {\r\n    if (hasTag && !nonSpace) {\r\n      while (spaces.length)\r\n        delete tokens[spaces.pop()];\r\n    } else {\r\n      spaces = [];\r\n    }\r\n\r\n    hasTag = false;\r\n    nonSpace = false;\r\n  }\r\n\r\n  var openingTagRe, closingTagRe, closingCurlyRe;\r\n  function compileTags (tagsToCompile) {\r\n    if (typeof tagsToCompile === 'string')\r\n      tagsToCompile = tagsToCompile.split(spaceRe, 2);\r\n\r\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\r\n      throw new Error('Invalid tags: ' + tagsToCompile);\r\n\r\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\r\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\r\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\r\n  }\r\n\r\n  compileTags(tags || mustache.tags);\r\n\r\n  var scanner = new Scanner(template);\r\n\r\n  var start, type, value, chr, token, openSection;\r\n  while (!scanner.eos()) {\r\n    start = scanner.pos;\r\n\r\n    // Match any text between tags.\r\n    value = scanner.scanUntil(openingTagRe);\r\n\r\n    if (value) {\r\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\r\n        chr = value.charAt(i);\r\n\r\n        if (isWhitespace(chr)) {\r\n          spaces.push(tokens.length);\r\n          indentation += chr;\r\n        } else {\r\n          nonSpace = true;\r\n          lineHasNonSpace = true;\r\n          indentation += ' ';\r\n        }\r\n\r\n        tokens.push([ 'text', chr, start, start + 1 ]);\r\n        start += 1;\r\n\r\n        // Check for whitespace on the current line.\r\n        if (chr === '\\n') {\r\n          stripSpace();\r\n          indentation = '';\r\n          tagIndex = 0;\r\n          lineHasNonSpace = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Match the opening tag.\r\n    if (!scanner.scan(openingTagRe))\r\n      break;\r\n\r\n    hasTag = true;\r\n\r\n    // Get the tag type.\r\n    type = scanner.scan(tagRe) || 'name';\r\n    scanner.scan(whiteRe);\r\n\r\n    // Get the tag value.\r\n    if (type === '=') {\r\n      value = scanner.scanUntil(equalsRe);\r\n      scanner.scan(equalsRe);\r\n      scanner.scanUntil(closingTagRe);\r\n    } else if (type === '{') {\r\n      value = scanner.scanUntil(closingCurlyRe);\r\n      scanner.scan(curlyRe);\r\n      scanner.scanUntil(closingTagRe);\r\n      type = '&';\r\n    } else {\r\n      value = scanner.scanUntil(closingTagRe);\r\n    }\r\n\r\n    // Match the closing tag.\r\n    if (!scanner.scan(closingTagRe))\r\n      throw new Error('Unclosed tag at ' + scanner.pos);\r\n\r\n    if (type == '>') {\r\n      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\r\n    } else {\r\n      token = [ type, value, start, scanner.pos ];\r\n    }\r\n    tagIndex++;\r\n    tokens.push(token);\r\n\r\n    if (type === '#' || type === '^') {\r\n      sections.push(token);\r\n    } else if (type === '/') {\r\n      // Check section nesting.\r\n      openSection = sections.pop();\r\n\r\n      if (!openSection)\r\n        throw new Error('Unopened section \"' + value + '\" at ' + start);\r\n\r\n      if (openSection[1] !== value)\r\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\r\n    } else if (type === 'name' || type === '{' || type === '&') {\r\n      nonSpace = true;\r\n    } else if (type === '=') {\r\n      // Set the tags for the next time around.\r\n      compileTags(value);\r\n    }\r\n  }\r\n\r\n  stripSpace();\r\n\r\n  // Make sure there are no open sections when we're done.\r\n  openSection = sections.pop();\r\n\r\n  if (openSection)\r\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\r\n\r\n  return nestTokens(squashTokens(tokens));\r\n}\r\n\r\n/**\r\n * Combines the values of consecutive text tokens in the given `tokens` array\r\n * to a single token.\r\n */\r\nfunction squashTokens (tokens) {\r\n  var squashedTokens = [];\r\n\r\n  var token, lastToken;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    token = tokens[i];\r\n\r\n    if (token) {\r\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\r\n        lastToken[1] += token[1];\r\n        lastToken[3] = token[3];\r\n      } else {\r\n        squashedTokens.push(token);\r\n        lastToken = token;\r\n      }\r\n    }\r\n  }\r\n\r\n  return squashedTokens;\r\n}\r\n\r\n/**\r\n * Forms the given array of `tokens` into a nested tree structure where\r\n * tokens that represent a section have two additional items: 1) an array of\r\n * all tokens that appear in that section and 2) the index in the original\r\n * template that represents the end of that section.\r\n */\r\nfunction nestTokens (tokens) {\r\n  var nestedTokens = [];\r\n  var collector = nestedTokens;\r\n  var sections = [];\r\n\r\n  var token, section;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    token = tokens[i];\r\n\r\n    switch (token[0]) {\r\n      case '#':\r\n      case '^':\r\n        collector.push(token);\r\n        sections.push(token);\r\n        collector = token[4] = [];\r\n        break;\r\n      case '/':\r\n        section = sections.pop();\r\n        section[5] = token[2];\r\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\r\n        break;\r\n      default:\r\n        collector.push(token);\r\n    }\r\n  }\r\n\r\n  return nestedTokens;\r\n}\r\n\r\n/**\r\n * A simple string scanner that is used by the template parser to find\r\n * tokens in template strings.\r\n */\r\nfunction Scanner (string) {\r\n  this.string = string;\r\n  this.tail = string;\r\n  this.pos = 0;\r\n}\r\n\r\n/**\r\n * Returns `true` if the tail is empty (end of string).\r\n */\r\nScanner.prototype.eos = function eos () {\r\n  return this.tail === '';\r\n};\r\n\r\n/**\r\n * Tries to match the given regular expression at the current position.\r\n * Returns the matched text if it can match, the empty string otherwise.\r\n */\r\nScanner.prototype.scan = function scan (re) {\r\n  var match = this.tail.match(re);\r\n\r\n  if (!match || match.index !== 0)\r\n    return '';\r\n\r\n  var string = match[0];\r\n\r\n  this.tail = this.tail.substring(string.length);\r\n  this.pos += string.length;\r\n\r\n  return string;\r\n};\r\n\r\n/**\r\n * Skips all text until the given regular expression can be matched. Returns\r\n * the skipped string, which is the entire tail if no match can be made.\r\n */\r\nScanner.prototype.scanUntil = function scanUntil (re) {\r\n  var index = this.tail.search(re), match;\r\n\r\n  switch (index) {\r\n    case -1:\r\n      match = this.tail;\r\n      this.tail = '';\r\n      break;\r\n    case 0:\r\n      match = '';\r\n      break;\r\n    default:\r\n      match = this.tail.substring(0, index);\r\n      this.tail = this.tail.substring(index);\r\n  }\r\n\r\n  this.pos += match.length;\r\n\r\n  return match;\r\n};\r\n\r\n/**\r\n * Represents a rendering context by wrapping a view object and\r\n * maintaining a reference to the parent context.\r\n */\r\nfunction Context (view, parentContext) {\r\n  this.view = view;\r\n  this.cache = { '.': this.view };\r\n  this.parent = parentContext;\r\n}\r\n\r\n/**\r\n * Creates a new context using the given view with this context\r\n * as the parent.\r\n */\r\nContext.prototype.push = function push (view) {\r\n  return new Context(view, this);\r\n};\r\n\r\n/**\r\n * Returns the value of the given name in this context, traversing\r\n * up the context hierarchy if the value is absent in this context's view.\r\n */\r\nContext.prototype.lookup = function lookup (name) {\r\n  var cache = this.cache;\r\n\r\n  var value;\r\n  if (cache.hasOwnProperty(name)) {\r\n    value = cache[name];\r\n  } else {\r\n    var context = this, intermediateValue, names, index, lookupHit = false;\r\n\r\n    while (context) {\r\n      if (name.indexOf('.') > 0) {\r\n        intermediateValue = context.view;\r\n        names = name.split('.');\r\n        index = 0;\r\n\r\n        /**\r\n         * Using the dot notion path in `name`, we descend through the\r\n         * nested objects.\r\n         *\r\n         * To be certain that the lookup has been successful, we have to\r\n         * check if the last object in the path actually has the property\r\n         * we are looking for. We store the result in `lookupHit`.\r\n         *\r\n         * This is specially necessary for when the value has been set to\r\n         * `undefined` and we want to avoid looking up parent contexts.\r\n         *\r\n         * In the case where dot notation is used, we consider the lookup\r\n         * to be successful even if the last \"object\" in the path is\r\n         * not actually an object but a primitive (e.g., a string, or an\r\n         * integer), because it is sometimes useful to access a property\r\n         * of an autoboxed primitive, such as the length of a string.\r\n         **/\r\n        while (intermediateValue != null && index < names.length) {\r\n          if (index === names.length - 1)\r\n            lookupHit = (\r\n              hasProperty(intermediateValue, names[index])\r\n              || primitiveHasOwnProperty(intermediateValue, names[index])\r\n            );\r\n\r\n          intermediateValue = intermediateValue[names[index++]];\r\n        }\r\n      } else {\r\n        intermediateValue = context.view[name];\r\n\r\n        /**\r\n         * Only checking against `hasProperty`, which always returns `false` if\r\n         * `context.view` is not an object. Deliberately omitting the check\r\n         * against `primitiveHasOwnProperty` if dot notation is not used.\r\n         *\r\n         * Consider this example:\r\n         * ```\r\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\r\n         * ```\r\n         *\r\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\r\n         * in the dot notation case, then render call would return:\r\n         *\r\n         * \"The length of a football field is 9.\"\r\n         *\r\n         * rather than the expected:\r\n         *\r\n         * \"The length of a football field is 100 yards.\"\r\n         **/\r\n        lookupHit = hasProperty(context.view, name);\r\n      }\r\n\r\n      if (lookupHit) {\r\n        value = intermediateValue;\r\n        break;\r\n      }\r\n\r\n      context = context.parent;\r\n    }\r\n\r\n    cache[name] = value;\r\n  }\r\n\r\n  if (isFunction(value))\r\n    value = value.call(this.view);\r\n\r\n  return value;\r\n};\r\n\r\n/**\r\n * A Writer knows how to take a stream of tokens and render them to a\r\n * string, given a context. It also maintains a cache of templates to\r\n * avoid the need to parse the same template twice.\r\n */\r\nfunction Writer () {\r\n  this.templateCache = {\r\n    _cache: {},\r\n    set: function set (key, value) {\r\n      this._cache[key] = value;\r\n    },\r\n    get: function get (key) {\r\n      return this._cache[key];\r\n    },\r\n    clear: function clear () {\r\n      this._cache = {};\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Clears all cached templates in this writer.\r\n */\r\nWriter.prototype.clearCache = function clearCache () {\r\n  if (typeof this.templateCache !== 'undefined') {\r\n    this.templateCache.clear();\r\n  }\r\n};\r\n\r\n/**\r\n * Parses and caches the given `template` according to the given `tags` or\r\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\r\n * that is generated from the parse.\r\n */\r\nWriter.prototype.parse = function parse (template, tags) {\r\n  var cache = this.templateCache;\r\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\r\n  var isCacheEnabled = typeof cache !== 'undefined';\r\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\r\n\r\n  if (tokens == undefined) {\r\n    tokens = parseTemplate(template, tags);\r\n    isCacheEnabled && cache.set(cacheKey, tokens);\r\n  }\r\n  return tokens;\r\n};\r\n\r\n/**\r\n * High-level method that is used to render the given `template` with\r\n * the given `view`.\r\n *\r\n * The optional `partials` argument may be an object that contains the\r\n * names and templates of partials that are used in the template. It may\r\n * also be a function that is used to load partial templates on the fly\r\n * that takes a single argument: the name of the partial.\r\n *\r\n * If the optional `config` argument is given here, then it should be an\r\n * object with a `tags` attribute or an `escape` attribute or both.\r\n * If an array is passed, then it will be interpreted the same way as\r\n * a `tags` attribute on a `config` object.\r\n *\r\n * The `tags` attribute of a `config` object must be an array with two\r\n * string values: the opening and closing tags used in the template (e.g.\r\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\r\n *\r\n * The `escape` attribute of a `config` object must be a function which\r\n * accepts a string as input and outputs a safely escaped string.\r\n * If an `escape` function is not provided, then an HTML-safe string\r\n * escaping function is used as the default.\r\n */\r\nWriter.prototype.render = function render (template, view, partials, config) {\r\n  var tags = this.getConfigTags(config);\r\n  var tokens = this.parse(template, tags);\r\n  var context = (view instanceof Context) ? view : new Context(view, undefined);\r\n  return this.renderTokens(tokens, context, partials, template, config);\r\n};\r\n\r\n/**\r\n * Low-level method that renders the given array of `tokens` using\r\n * the given `context` and `partials`.\r\n *\r\n * Note: The `originalTemplate` is only ever used to extract the portion\r\n * of the original template that was contained in a higher-order section.\r\n * If the template doesn't use higher-order sections, this argument may\r\n * be omitted.\r\n */\r\nWriter.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {\r\n  var buffer = '';\r\n\r\n  var token, symbol, value;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    value = undefined;\r\n    token = tokens[i];\r\n    symbol = token[0];\r\n\r\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\r\n    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\r\n    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\r\n    else if (symbol === '&') value = this.unescapedValue(token, context);\r\n    else if (symbol === 'name') value = this.escapedValue(token, context, config);\r\n    else if (symbol === 'text') value = this.rawValue(token);\r\n\r\n    if (value !== undefined)\r\n      buffer += value;\r\n  }\r\n\r\n  return buffer;\r\n};\r\n\r\nWriter.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {\r\n  var self = this;\r\n  var buffer = '';\r\n  var value = context.lookup(token[1]);\r\n\r\n  // This function is used to render an arbitrary template\r\n  // in the current context by higher-order sections.\r\n  function subRender (template) {\r\n    return self.render(template, context, partials, config);\r\n  }\r\n\r\n  if (!value) return;\r\n\r\n  if (isArray(value)) {\r\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\r\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\r\n    }\r\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\r\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\r\n  } else if (isFunction(value)) {\r\n    if (typeof originalTemplate !== 'string')\r\n      throw new Error('Cannot use higher-order sections without the original template');\r\n\r\n    // Extract the portion of the original template that the section contains.\r\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\r\n\r\n    if (value != null)\r\n      buffer += value;\r\n  } else {\r\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\r\n  }\r\n  return buffer;\r\n};\r\n\r\nWriter.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {\r\n  var value = context.lookup(token[1]);\r\n\r\n  // Use JavaScript's definition of falsy. Include empty arrays.\r\n  // See https://github.com/janl/mustache.js/issues/186\r\n  if (!value || (isArray(value) && value.length === 0))\r\n    return this.renderTokens(token[4], context, partials, originalTemplate, config);\r\n};\r\n\r\nWriter.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\r\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\r\n  var partialByNl = partial.split('\\n');\r\n  for (var i = 0; i < partialByNl.length; i++) {\r\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\r\n      partialByNl[i] = filteredIndentation + partialByNl[i];\r\n    }\r\n  }\r\n  return partialByNl.join('\\n');\r\n};\r\n\r\nWriter.prototype.renderPartial = function renderPartial (token, context, partials, config) {\r\n  if (!partials) return;\r\n  var tags = this.getConfigTags(config);\r\n\r\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\r\n  if (value != null) {\r\n    var lineHasNonSpace = token[6];\r\n    var tagIndex = token[5];\r\n    var indentation = token[4];\r\n    var indentedValue = value;\r\n    if (tagIndex == 0 && indentation) {\r\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\r\n    }\r\n    var tokens = this.parse(indentedValue, tags);\r\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\r\n  }\r\n};\r\n\r\nWriter.prototype.unescapedValue = function unescapedValue (token, context) {\r\n  var value = context.lookup(token[1]);\r\n  if (value != null)\r\n    return value;\r\n};\r\n\r\nWriter.prototype.escapedValue = function escapedValue (token, context, config) {\r\n  var escape = this.getConfigEscape(config) || mustache.escape;\r\n  var value = context.lookup(token[1]);\r\n  if (value != null)\r\n    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\r\n};\r\n\r\nWriter.prototype.rawValue = function rawValue (token) {\r\n  return token[1];\r\n};\r\n\r\nWriter.prototype.getConfigTags = function getConfigTags (config) {\r\n  if (isArray(config)) {\r\n    return config;\r\n  }\r\n  else if (config && typeof config === 'object') {\r\n    return config.tags;\r\n  }\r\n  else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nWriter.prototype.getConfigEscape = function getConfigEscape (config) {\r\n  if (config && typeof config === 'object' && !isArray(config)) {\r\n    return config.escape;\r\n  }\r\n  else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nvar mustache = {\r\n  name: 'mustache.js',\r\n  version: '4.2.0',\r\n  tags: [ '{{', '}}' ],\r\n  clearCache: undefined,\r\n  escape: undefined,\r\n  parse: undefined,\r\n  render: undefined,\r\n  Scanner: undefined,\r\n  Context: undefined,\r\n  Writer: undefined,\r\n  /**\r\n   * Allows a user to override the default caching strategy, by providing an\r\n   * object with set, get and clear methods. This can also be used to disable\r\n   * the cache by setting it to the literal `undefined`.\r\n   */\r\n  set templateCache (cache) {\r\n    defaultWriter.templateCache = cache;\r\n  },\r\n  /**\r\n   * Gets the default or overridden caching object from the default writer.\r\n   */\r\n  get templateCache () {\r\n    return defaultWriter.templateCache;\r\n  }\r\n};\r\n\r\n// All high-level mustache.* functions use this writer.\r\nvar defaultWriter = new Writer();\r\n\r\n/**\r\n * Clears all cached templates in the default writer.\r\n */\r\nmustache.clearCache = function clearCache () {\r\n  return defaultWriter.clearCache();\r\n};\r\n\r\n/**\r\n * Parses and caches the given template in the default writer and returns the\r\n * array of tokens it contains. Doing this ahead of time avoids the need to\r\n * parse templates on the fly as they are rendered.\r\n */\r\nmustache.parse = function parse (template, tags) {\r\n  return defaultWriter.parse(template, tags);\r\n};\r\n\r\n/**\r\n * Renders the `template` with the given `view`, `partials`, and `config`\r\n * using the default writer.\r\n */\r\nmustache.render = function render (template, view, partials, config) {\r\n  if (typeof template !== 'string') {\r\n    throw new TypeError('Invalid template! Template should be a \"string\" ' +\r\n                        'but \"' + typeStr(template) + '\" was given as the first ' +\r\n                        'argument for mustache#render(template, view, partials)');\r\n  }\r\n\r\n  return defaultWriter.render(template, view, partials, config);\r\n};\r\n\r\n// Export the escaping function so that the user may override it.\r\n// See https://github.com/janl/mustache.js/issues/244\r\nmustache.escape = escapeHtml;\r\n\r\n// Export these mainly for testing, but also for advanced usage.\r\nmustache.Scanner = Scanner;\r\nmustache.Context = Context;\r\nmustache.Writer = Writer;\r\n\r\nexport default mustache;","export const basicRender = (html, context) => {\r\n\r\n    let workshop = document.createElement(\"div\");\r\n\r\n    workshop.innerHTML = html;\r\n\r\n    workshop.querySelectorAll(\"[data-context]\").forEach((el)=>{\r\n\r\n        let binding = el.dataset.context?.split(\".\");\r\n\r\n        let cache = context;\r\n\r\n        binding.forEach((key)=>{\r\n            cache = cache[key];\r\n        });\r\n\r\n        el.textContent = interpretData(cache);\r\n\r\n    });\r\n    return workshop.innerHTML;\r\n};\r\n\r\nconst interpretData = (data) => {\r\n\r\n    // This is where you would customize instead of just convert everything to a string.\r\n\r\n    return `${data}`;\r\n};","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n","import mustache from './libs/mustache.js';\r\n\r\n/**\r\n * Class representing a bindable View or Model\r\n */\r\nclass Bindable {\r\n    constructor() {\r\n        this.subscribers = [];\r\n        this.subscriptions = [];\r\n    }\r\n\r\n    send() {\r\n        this.subscribers.forEach((item) => {\r\n            item.receive?.(this.getData());\r\n        });\r\n    }\r\n\r\n    receive(data) {\r\n        this.setData(data);\r\n    }\r\n\r\n    requestUpdate() {\r\n        this.subscriptions.forEach((item) => {\r\n            this.receive(item.getData());\r\n        });\r\n    }\r\n\r\n    getData() {\r\n        // Implemented at the View/Model level\r\n    }\r\n\r\n    setData() {\r\n        // Implemented at the View/Modal level\r\n    }\r\n\r\n    subscribe(subscriber) {\r\n        this.subscribers.push(subscriber);\r\n        subscriber.subscriptions?.push(this);\r\n    }\r\n\r\n    unsubscribe(subscriber) {\r\n        this.subscribers = this.subscribers.filter(x => x !== subscriber);\r\n        subscriber.subscriptions = subscriber.subscriptions.filter(x => x !== this);\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing an HTML view that is bound to a data Model\r\n */\r\nexport class View extends Bindable {\r\n    constructor(element) {\r\n        super();\r\n        let bindInfo = element.dataset.bind?.split(\":\");\r\n        this.quiet = false; // prevents sends on an update\r\n        this.element = element;\r\n        this.action = bindInfo?.[0];\r\n        this.target = bindInfo?.[1];\r\n        this.subContext = element.dataset.context;\r\n        this.template = this.element.querySelector(\"template\")?.innerHTML;\r\n\r\n        if (element.dataset.bindOn) {\r\n            element.addEventListener(element.dataset.bindOn, this.send.bind(this));\r\n        }\r\n    }\r\n\r\n    setData(data) {\r\n        let method = `render_${this.target}`;\r\n        this[method]?.bind(this)?.(data);\r\n    }\r\n\r\n    getData() {\r\n        let data = this.element[this.target] ?? null;\r\n\r\n        let wrapper = {};\r\n\r\n        wrapper[this.subContext ?? \"data\"] = data;\r\n\r\n        return wrapper;\r\n    }\r\n\r\n    setContext(context) {\r\n        this.subscriptions = [context];\r\n    }\r\n\r\n    render_innerHTML(context) {\r\n        context = context[this.subContext] ?? context;\r\n        this.element.innerHTML = context;\r\n    }\r\n\r\n    render_template(context) {\r\n        context = context[this.subContext] ?? context;\r\n        if (this.template) {\r\n            this.element.innerHTML = mustache.render(this.template, context);\r\n        }\r\n    }\r\n\r\n    render_value(context) {\r\n        context = context[this.subContext] ?? context;\r\n        this.element.value = context;\r\n    }\r\n\r\n    send() {\r\n        if (this.quiet === true) return false;\r\n        super.send();\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing a data Model which can be bound to an HTML View\r\n */\r\nexport class Model extends Bindable {\r\n    constructor(data) {\r\n        super();\r\n        this.data = data;\r\n        this.quiet = false; // prevents sends on an update\r\n    }\r\n\r\n    getData() {\r\n        return this.data;\r\n    }\r\n\r\n    setData(data) {\r\n        this.data = { ...this.data, ...data }\r\n        this.send();\r\n    }\r\n\r\n    replaceData(newData) {\r\n        this.data = newData;\r\n        this.send();\r\n    }\r\n\r\n    send() {\r\n        if (this.quiet === true) return false;\r\n        super.send();\r\n    }\r\n}","import defineProperty from './_define_property';\n\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import { View, Model } from './class_Bindable.js';\r\n\r\nimport { getJsonPromise, getHtmlPromise } from './helper_ajax.js';\r\n\r\nexport const bindings = {\r\n    models: [],\r\n    views: []\r\n};\r\n\r\nconst getViews = () => {\r\n\r\n    try {\r\n        let viewList = [];\r\n\r\n        let targetList = document.querySelectorAll(\"[data-bind]\");\r\n\r\n        targetList.forEach((el) => {\r\n\r\n            viewList.push(new View(el));\r\n\r\n        });\r\n        return viewList;\r\n    } catch (error) {\r\n\r\n        return [error];\r\n    }\r\n};\r\n\r\nconst getModel = async (context) => {\r\n\r\n    try {\r\n        if (typeof context === \"object\") {\r\n            return new Model(context);\r\n        }\r\n\r\n        let imported = await getJsonPromise(context);\r\n\r\n        return new Model(imported);\r\n\r\n    } catch (error) {\r\n        return error;\r\n    }\r\n};\r\n\r\nconst subscribeViews = (views, sender) => {\r\n    views.forEach((item) => {\r\n        if (item.action === \"receive\") {\r\n            sender.subscribe(item);\r\n        }\r\n        // give views the initial data value.\r\n        item.receive(sender.getData());\r\n    });\r\n}\r\n\r\nconst subscribeModels = (models, sender) => {\r\n    models.forEach((item) => {\r\n        if (sender.action === \"send\") {\r\n            sender.subscribe(item);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * - Setup Bindings\r\n * @param {any} context \r\n */\r\nbindings.setup = async (context) => {\r\n\r\n    bindings.models.push(await getModel(context));\r\n\r\n    bindings.views = getViews(bindings.pageContext);\r\n\r\n    bindings.models.forEach((model) => {\r\n        subscribeViews(bindings.views, model);\r\n    });\r\n\r\n    bindings.views.forEach((view) => {\r\n        subscribeModels(bindings.models, view);\r\n    });\r\n\r\n    // Updating isn't necessary since the initial setup injects the values\r\n\r\n    window._bindings = bindings; // debug\r\n\r\n};\r\n\r\nbindings.update = (item) => {\r\n    item.send();\r\n}\r\n\r\nbindings.updateAll = () => {\r\n\r\n    bindings.models.forEach((model) => {\r\n        model.send();\r\n    });\r\n\r\n    bindings.views.forEach((view) => {\r\n        view.send();\r\n    });\r\n\r\n};\r\n\r\n\r\n\r\n","import { Modal } from './class_Modal.js';\r\n\r\nexport const ui = {};\r\n\r\nui.message = (content) => {\r\n    let modal = new Modal(content);\r\n    modal.show();\r\n}\r\n\r\nui.alert = (content) => {\r\n    let modal = new Modal(content);\r\n    modal.alert();\r\n};\r\n\r\nui.warn = (content) => {\r\n    let modal = new Modal(content);\r\n    return modal.warn();\r\n};\r\n\r\nui.confirm = async (content) => {\r\n\r\n    try {\r\n        let modal = new Modal(content);\r\n\r\n        let result = await modal.confirm();\r\n\r\n        return result;\r\n    } catch (error) {\r\n        return error;\r\n    }\r\n};\r\n\r\nui.textInput = async (content) => {\r\n    try {\r\n        let modal = new Modal(content);\r\n\r\n        let result = await modal.textInput();\r\n\r\n        return result;\r\n\r\n    } catch (error) {\r\n        return error;\r\n    }\r\n}","import { events } from './custom_events.js';\r\n\r\nimport { getHtmlPromise, getJsonPromise, postDataPromise } from './helper_ajax.js';\r\n\r\nimport { Template } from './class_Template.js';\r\n\r\nimport { Modal } from './class_Modal.js';\r\n\r\nimport { Benchmark } from './class_Benchmark.js';\r\n\r\nimport { bindings } from './helper_binding.js';\r\n\r\nimport { ui } from './helper_ui.js';\r\n\r\n// Decide what you want to import/export for your own project's use. \r\nexport {\r\n    Template, Modal, Benchmark,\r\n    events, bindings, ui,\r\n    getHtmlPromise, getJsonPromise, postDataPromise\r\n};\r\n\r\nwindow._ = {\r\n    Template: Template,\r\n    Modal: Modal,\r\n    Benchmark: Benchmark,\r\n    events: events,\r\n    bindings: bindings,\r\n    ui: ui,\r\n    getHTML: getHtmlPromise,\r\n    getJSON: getJsonPromise,\r\n    postData: postDataPromise\r\n};\r\n\r\n/**\r\n * Here we add event listeners and setup the app. \r\n */\r\ndocument.body.addEventListener(\"keyup\", (e) => {\r\n\r\n    events.keyup[e.target.dataset.keyup]?.(e.target, e);\r\n});\r\n\r\ndocument.body.addEventListener(\"change\", (e) => {\r\n\r\n    events.change[e.target.dataset.change]?.(e.target, e);\r\n});\r\n\r\ndocument.body.addEventListener(\"click\", (e) => {\r\n\r\n    events.click[e.target.dataset.click]?.(e.target, e);\r\n});\r\n\r\n","import { getJsonPromise, getHtmlPromise } from './helper_ajax.js';\r\n\r\nimport Mustache from './libs/mustache.js';\r\n\r\nimport {basicRender} from './helper_template.js';\r\n\r\n/**\r\n * - A class representing a template for rendering content onto the page. \r\n */\r\nexport class Template {\r\n    constructor(settings) {\r\n\r\n        if (typeof settings === \"object\") {\r\n            Object.assign(this, settings);\r\n        }\r\n\r\n        this.context = this.context || {};\r\n        this.html = this.html ?? \"\";\r\n        this.engine = this.engine ?? \"default\";\r\n        this.target = this.target ?? \"#NoTargetSelected\";\r\n        this.rendered = this.rendered ?? \"\";\r\n        this.dataUrl = this.dataUrl ?? null;\r\n        this.htmlUrl = this.htmlUrl ?? null;\r\n        this.autoRender = this.autoRender || false;\r\n\r\n        this.engines = {\r\n            default: () => {\r\n                return basicRender(this.html, this.context);\r\n            },\r\n            mustache: () => {\r\n                return Mustache.render(this.html, this.context);\r\n            }\r\n        };\r\n\r\n        //let {prep_func: ()=>{ return (object, render)=>{//Code Here}}};\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {object} items - Merge items with context. For Mustache render helpers\r\n     * use this format: {prep_func: ()=>{ return (object, render)=>{//Code Here}}};\r\n     */\r\n    enhanceContext(items) {\r\n        Object.assign(this.context, items);\r\n    }\r\n\r\n    /**\r\n     * - Gets HTML from a URL and sets the html field. \r\n     * @param {string} url \r\n     * @param {boolean} noRender - flag to prevent unnecessary rendering\r\n     * @returns a promise object with the result. \r\n     */\r\n    async importPartial(url, noRender) {\r\n\r\n        const self = this;\r\n\r\n        url = url ?? self.htmlUrl;\r\n\r\n        try {\r\n            let result = await getHtmlPromise(url);\r\n            self.html = result;\r\n            if (self.autoRender && noRender != true) self.render(self.target);\r\n            return result;\r\n        }\r\n        catch (error) {\r\n            return error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * - Gets JSON from a URL and sets the context field. \r\n     * @param {string} url \r\n     * @param {boolean} noRender \r\n     * @returns A promise object with the result.\r\n     */\r\n    async importContext(url, noRender) {\r\n\r\n        const self = this;\r\n\r\n        url = url ?? self.dataUrl;\r\n\r\n        try {\r\n            let result = await getJsonPromise(url);\r\n            self.context = result;\r\n            if (self.autoRender && noRender != true) self.render(self.target);\r\n            return result;\r\n        }\r\n        catch (error) {\r\n            return error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * - Gets JSON/HTML from a URL and sets the context & html fields. \r\n     * @param {string} dataUrl - URL of JSON string\r\n     * @param {*} templateUrl - URL of HTML text\r\n     * @returns a promise object with a reference to the template. \r\n     */\r\n    async importPackage(dataUrl, templateUrl) {\r\n\r\n        let self = this;\r\n\r\n        dataUrl = dataUrl ?? self.dataUrl;\r\n        \r\n        templateUrl = templateUrl ?? self.templateUrl;\r\n\r\n        await this.importPartial(templateUrl, true);\r\n\r\n        await this.importContext(dataUrl, true);\r\n\r\n        if (self.autoRender) self.render(self.target);\r\n\r\n        return self;\r\n    }\r\n\r\n    /**\r\n     * - Gets HTML from a template already on the page. Can render if the\r\n     * target is already set. \r\n     * @param {string} selector \r\n     * @returns a reference to the template instance for chaining. \r\n     */\r\n    load(selector) {\r\n\r\n        if(!selector){\r\n            selector = `[data-template-for='${this.target.replace(\"#\",\"\")}']`\r\n        }\r\n\r\n        let template = document.querySelector(selector);\r\n\r\n        let engine = template.dataset.engine ?? \"default\";\r\n\r\n        this.html = template.innerHTML ?? \"<em>No Template Found</em>\";\r\n\r\n        this.engine = engine;\r\n\r\n        if (this.autoRender) this.render(this.target);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * - Renders the current template to the innerHTML of the element\r\n     * matching the provided selector. \r\n     * @param {string} selector \r\n     * @returns a reference to the tamplet instance for chaining. \r\n     */\r\n    render(selector) {\r\n\r\n        if(!selector && this.target.length > 1){\r\n            selector = this.target;\r\n        }\r\n\r\n        let target = document.querySelector(selector);\r\n\r\n        let rendered = this.engines[this.engine]?.();\r\n\r\n        this.rendered = rendered;\r\n\r\n        if (target?.innerHTML) {\r\n            target.innerHTML = rendered;\r\n        }\r\n        return this.rendered;\r\n    }\r\n\r\n}","/**\r\n * Class representing a performance benchmark.\r\n */\r\nexport class Benchmark {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.start = performance.now();\r\n        this.result = 0;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns a completed benchmark\r\n     */\r\n    stop() {\r\n        this.result = performance.now() - this.start;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * verbose benchmark output\r\n     */\r\n    get detailedResults() {\r\n        return `Task \"${this.name}\" executed in ${this.result} ms.`;\r\n    }\r\n}"],"names":["$a854a37bfc048b592c92e2adf0fa1182$export$b3e36f066d3bceb9","this","element","remove","modalContent","content","innerHTML","body","appendChild","template","confirmYes","resolve","error","reject","self","close","callbacks","processTextInput","e","text","document","getElementById","value","show","$81556083f5a1eed570cac8665cb60574$export$fc4ac6ce2f1d593c","click","change","keyup","actions","$61037ebbadd07cc93d1ba4ba1609e324$export$e7f8695b207ce249","[object Object]","url","from","data","callback","returnType","JSON","parse","requestType","xhr","setRequestHeader","keys","map","key","str","_prepHeaders","Promise","Request1","status","_processReturn","response","onerror","$74465f9716924a65f65e5f514668d4cb$export$bb7e79c84dee9e44","$61037ebbadd07cc93d1ba4ba1609e324$export$ae4f7751a06ad53d","send","$74465f9716924a65f65e5f514668d4cb$export$4aa02d87adfb76de","Array","isArray","object","call","isFunction","escapeRegExp","string","replace","hasProperty","obj","propName","RegExp","prototype","test","re","regExpTest","testRegExp","nonSpaceRe",">","\"","'","/","`","=","curlyRe","tagRe","Scanner","Context","view","parentContext","cache",".","parent","Writer","templateCache","_cache","tail","match","index","length","search","substring","hasOwnProperty","name","intermediateValue","names","context","lookupHit","indexOf","split","primitive","clearCache","clear","tags","cacheKey","mustache","join","isCacheEnabled","tokens","get","undefined","closingTagRe","closingCurlyRe","stripSpace","hasTag","nonSpace","spaces","pop","tagsToCompile","Error","type","chr","token","openSection","scanner","eos","pos","scanUntil","openingTagRe","i","valueLength","isWhitespace","charAt","push","indentation","lineHasNonSpace","start","scan","whiteRe","equalsRe","tagIndex","sections","collector","nestedTokens","lastToken","numTokens","squashedTokens","parseTemplate","set","String","s","entityMap","$26b71dd9f672a4edac89ddced9733cc8$var$interpretData","Object","defineProperty","enumerable","configurable","writable","subscribers","forEach","item","setData","subscriber","ref","subscriptions","filter","x","$940cfe1778b88d06742ad05a41834001$var$Bindable","target","_obj","_target","wrapper","$2cmZE","default","render","ref1","dataset","bind","quiet","action","bindInfo","subContext","arguments","source","ownKeys","getOwnPropertySymbols","concat","sym","getOwnPropertyDescriptor","$9b41930264bd51dfbab97a625345f522$export$9099ad97b570f7c","$7f8fe3fdd1a7707a11b0180c9666710b$export$9099ad97b570f7c","newData","$8e4b8f2a3e178b51ba76c15701c98655$export$491842680a93f433","models","views","setup","async","$940cfe1778b88d06742ad05a41834001$export$4d9aa5949e79e4c","imported","$8e4b8f2a3e178b51ba76c15701c98655$var$getModel","viewList","querySelectorAll","el","$940cfe1778b88d06742ad05a41834001$export$ee39aefc8ac7973d","model","sender","subscribe","receive","getData","window","_bindings","update","$8641fe3f5aa8dc1e643bc71705a0258f$export$9704214ef6d90ae9","message","alert","warn","confirm","modal","textInput","_","Template","items","assign","noRender","result","html","dataUrl","templateUrl","importPartial","importContext","autoRender","selector","querySelector","_engine","engine","_innerHTML","rendered","workshop","createElement","binding","textContent","Modal","Benchmark","performance","now","events","bindings","ui","getHTML","getJSON","postData","$61037ebbadd07cc93d1ba4ba1609e324$export$d080338540ee233","to","addEventListener","_keyup","_change"],"version":3,"file":"app.min.js.map"}