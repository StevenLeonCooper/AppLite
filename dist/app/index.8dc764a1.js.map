{"mappings":"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","sources":["scripts/class_Modal.js","scripts/custom_events.js","scripts/class_Request.js","scripts/helper_ajax.js","scripts/libs/mustache.js","scripts/class_Template.js","scripts/class_Benchmark.js","scripts/app.js"],"sourcesContent":["/**\r\n * - A class representing a modal window. This is an alternative to using \r\n * window.alert() or window.confirm() to provide a better, more consistent\r\n * browsing experience for users. \r\n */\r\nexport class Modal {\r\n    constructor(content) {\r\n\r\n        let modalWindow = document.createElement(\"div\");\r\n\r\n        this.element = modalWindow;\r\n\r\n        this.content = content;\r\n\r\n        this.callbacks = {\r\n            close: () => { this.element.remove(); }\r\n        };\r\n\r\n        modalWindow.id = \"ModalWrapper\";\r\n\r\n        modalWindow.dataset.mclick = \"close\";\r\n\r\n        modalWindow.addEventListener(\"click\", (e, z) => {\r\n            let action = e.target?.dataset?.mclick;\r\n\r\n            this.callbacks[action]?.(e.target);\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * - Closes the active modal window.\r\n     */\r\n    close() {\r\n        this.element.remove();\r\n    }\r\n\r\n    /**\r\n     * - Render the modal window to the page. \r\n     */\r\n    show() {\r\n\r\n        let modalContent = `<div id=\"ModalContent\">${this.content}</div>`;\r\n\r\n        this.element.innerHTML = modalContent;\r\n\r\n        document.body.appendChild(this.element);\r\n    }\r\n\r\n    /**\r\n     * This implementation simply uses an alternate template for the content.\r\n     */\r\n    alert() {\r\n        let template = `<h1>Alert</h1><hr>\r\n                            <div id=\"Alert\">${this.content}<hr>\r\n                            <button data-mclick=\"close\" id=\"CloseModal\">Okay</button>\r\n                            </div>`;\r\n\r\n        this.content = template;\r\n\r\n        this.show();\r\n    }\r\n\r\n    /**\r\n     * This implementation includes warning text and returns false. \r\n     */\r\n    warn() {\r\n        let template = `<h1>Warning</h1><hr>\r\n                        <div id=\"Warning\">${this.content}<hr>\r\n                        <button data-mclick=\"close\" id=\"CloseModal\">Okay</button>\r\n                        </div>`;\r\n\r\n        this.content = template;\r\n\r\n        this.show();\r\n\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * - This implementation creates a confirm/decline dialogue and invokes callbacks for each. \r\n     * @param {function} ifYes \r\n     * @param {function} ifNo \r\n     */\r\n    confirm(ifYes, ifNo) {\r\n        let template = `<h1>Confirm</h1><hr>\r\n                        <div id=\"Confirm\">${this.content}<hr>\r\n                            <button data-mclick=\"confirmYes\">Yes</button>\r\n                            <button data-mclick=\"confirmNo\">No</button>\r\n                        </div>`;\r\n\r\n        this.content = template;\r\n\r\n        this.callbacks.confirmYes = () => {\r\n            this.close();\r\n            ifYes?.();\r\n        };\r\n\r\n        this.callbacks.confirmNo = () => {\r\n            this.close();\r\n            ifNo?.();\r\n        };\r\n\r\n        this.show();\r\n    }\r\n\r\n    /**\r\n     * This implementation provides text input for the user and then sends it to the provided callback for use. \r\n     */\r\n    textInput(callback) {\r\n        \r\n        let template = \r\n        `<h2>Input Text</h2>\r\n        <textarea id=\"TextInput\" class=\"modal-input\">Copy/Paste Here</textarea><hr>\r\n        <button data-mclick=\"processTextInput\">Continue</button>`;\r\n\r\n        this.content = template;\r\n\r\n        this.callbacks.processTextInput = (e) => {\r\n\r\n            let text = document.getElementById(\"TextInput\").value;\r\n\r\n            this.close();\r\n\r\n            callback.call(e.target, text);\r\n        };\r\n\r\n        this.show();\r\n    }\r\n}\r\n","import { Modal } from \"./class_Modal.js\";\r\n\r\nexport const events = {\r\n    click: {},\r\n    change: {},\r\n    keyup: {},\r\n    actions: {}\r\n};\r\n\r\n/**\r\n * - Trigger an event (like jQuery's $().trigger)\r\n * @param {string} name \r\n * @param {object} data \r\n * @param {HTMLElement} element \r\n */\r\nconst triggerEvent = (name, data, element) => {\r\n    let eventData = { detail: data };\r\n    let event = new CustomEvent(name, eventData);\r\n\r\n    element = element ?? document;\r\n\r\n    element.dispatchEvent?.(event, eventData);\r\n};\r\n\r\n/**\r\n * - Trigger an event on all elements that match a query. \r\n * @param {string} name \r\n * @param {object} data \r\n * @param {string} selector - Query that will return multiple elements\r\n */\r\nconst triggerEventAll = (name, data, selector) => {\r\n\r\n    try {\r\n        let elements = document.querySelectorAll(selector);\r\n\r\n        elements.forEach((item) => {\r\n            triggerEvent(name, data, item);\r\n        });\r\n\r\n    } catch (er) {\r\n        let message = new Modal(\"Error!\").show();\r\n    }\r\n};\r\n","/**\r\n * Class for making AJAX (XHR) requests\r\n */\r\nexport class Request {\r\n    /**\r\n     * \r\n     * @param {string} requestType - POST or GET\r\n     * @param {string} returnType  - Data expected on return (JSON/HTML)\r\n     * @param {string} url - URL for Request\r\n     * @param {object} data - Data to Send\r\n     */\r\n    constructor(requestType, returnType, url, data) {\r\n        if (typeof requestType === \"object\" && arguments.length == 1) {\r\n            Object.assign(this, requestType);\r\n        } else {\r\n            this.requestType = requestType ?? \"GET\";\r\n            this.returnType = returnType ?? \"JSON\";\r\n            this.url = url ?? \"\";\r\n            this.data = data ?? {};\r\n        }\r\n        this.thenHandler = () => { };\r\n        this.catchHandler = () => { };\r\n        this.xhr = new XMLHttpRequest();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * - Set the URL for a GET request.\r\n     * @param {string} url \r\n     * @returns a self reference for chaining.\r\n     */\r\n    from(url) {\r\n        this.url = url;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * - Set the URL for a POST request.\r\n     * @param {string} url \r\n     * @returns a self reference for chaining.\r\n     */\r\n    to(url) {\r\n        this.from(url);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the data to send in a request (POST or GET)\r\n     * Key-value-pairs are converted to URL params for GET requests.\r\n     * @param {object} data \r\n     * @returns a self reference for chaining.\r\n     */\r\n    using(data) {\r\n        this.data = data;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Deprecated - a callback for when the request completes. Use send() instead. \r\n     * @param {function} callback \r\n     * @returns  a self reference for chaining.\r\n     */\r\n    then(callback) {\r\n        this.thenHandler = callback;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Deprecated - a callback for catching request errors. Use send() instead. \r\n     * @param {function} callback \r\n     * @returns a self reference for chaining.\r\n     */\r\n    catch(callback) {\r\n        this.catchHandler = callback;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WARNING: This function is \"private\" & may return unexpected results. \r\n     * This determines whether to run the result through JSON.parse() to convert\r\n     * JSON back into normal JavaScript. \r\n     * @param {object} data \r\n     * @returns \r\n     */\r\n    _processReturn(data) {\r\n        if (this.returnType == \"JSON\") {\r\n            return JSON.parse(data);\r\n        }\r\n\r\n        if (this.returnType == \"HTML\") {\r\n            return data;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * WARNING: This function is \"private\" & may return unexpected results. \r\n     * This function formates the headers and/or data for POST/GET requests. \r\n     */\r\n    _prepHeaders() {\r\n        if (this.requestType === \"POST\") {\r\n            this.xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\r\n        }\r\n        if (this.requestType === \"GET\") {\r\n            var str = Object.keys(this.data).map(key => `${key}=${this.data[key]}`).join(\"&\");\r\n            this.url = `${this.url}?${str}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute the XHR Request\r\n     * @returns A promise object with the result.\r\n     */\r\n    async send() {\r\n        this._prepHeaders();\r\n\r\n        return new Promise((resolve, reject) => {\r\n            \r\n            const Request = this;\r\n\r\n            Request.xhr.open(Request.requestType, Request.url, true);\r\n\r\n            Request.xhr.onload = function () {\r\n                if (this.status >= 200 && this.status < 400) {\r\n                    var data = Request._processReturn(this.response);\r\n                    resolve(data);\r\n                }\r\n                reject(\"Moderate Error\");\r\n            };\r\n            Request.xhr.onerror = function () {\r\n                reject(\"Serious Error\");\r\n            };\r\n            // INITIATE AJAX REQUEST\r\n            Request.xhr.send(Request.data);\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deprecated - I recommend using the promisified version, send(). \r\n     * @returns a reference to the request instance. \r\n     */\r\n    now() {\r\n        this._prepHeaders();\r\n\r\n        const promise = new Promise((resolve, reject) => {\r\n            const Request = this;\r\n\r\n            Request.xhr.open(Request.requestType, Request.url, true);\r\n\r\n            Request.xhr.onload = function () {\r\n                if (this.status >= 200 && this.status < 400) {\r\n                    var data = Request._processReturn(this.response);\r\n                    resolve(data);\r\n                }\r\n                reject(\"Moderate Error\");\r\n            };\r\n            Request.xhr.onerror = function () {\r\n                reject(\"Serious Error\");\r\n            };\r\n            // INITIATE AJAX REQUEST\r\n            Request.xhr.send(Request.data);\r\n        })\r\n            .then(this.thenHandler)\r\n            .catch(this.catchHandler);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * A request preset to \"GET\"\r\n */\r\nexport class GET extends Request {\r\n    constructor(returnType) {\r\n        super(\"GET\", returnType, null, null);\r\n    }\r\n}\r\n\r\n/**\r\n * A request preset to \"POST\"\r\n */\r\nexport class POST extends Request {\r\n    constructor(data) {\r\n        super(\"POST\", null, null, data);\r\n    }\r\n}\r\n","import { GET, POST } from './class_Request.js';\r\n\r\n/**\r\n * - Deprecated, I recommend using the promisified version. \r\n * @param {string} url \r\n * @param {function} callback \r\n * @param {function} onError \r\n */\r\nexport const getJSON = (url, callback, onError) => {\r\n    let request = new GET(\"JSON\").from(url).then(callback).catch(onError);\r\n    request.now();\r\n}\r\n\r\n/**\r\n * - Deprecated, I recommend using the promisified version. \r\n * @param {string} url \r\n * @param {function} callback \r\n * @param {function} onError \r\n */\r\nexport const getHTML = (url, callback, onError) => {\r\n    let request = new GET(\"HTML\").from(url).then(callback).catch(onError);\r\n    request.now();\r\n};\r\n\r\n/**\r\n * - Deprecated, I recommend using the promisified version. \r\n * @param {string} url \r\n * @param {object} data\r\n * @param {function} callback \r\n * @param {function} onError \r\n */\r\nexport const postData = (url, data, callback, onError) => {\r\n    let request = new POST(data).to(url).then(callback).catch(onError);\r\n    request.now();\r\n};\r\n\r\n/**\r\n * - Post data asynchronously to a URL. \r\n * @param {string} url \r\n * @param {object} data \r\n * @returns - A promise object with the result \r\n */\r\nexport const postDataPromise = (url, data) => {\r\n    let request = new POST(data).to(url);\r\n    return request.send();\r\n};\r\n\r\n/**\r\n * - Get HTML text from a URL\r\n * @param {string} url \r\n * @returns - A promise object with the result\r\n */\r\nexport const getHtmlPromise = (url) => {\r\n    let request = new GET(\"HTML\").from(url);\r\n    return request.send();\r\n};\r\n\r\n/**\r\n * - Get JSON text from a URL\r\n * @param {string} url \r\n * @returns - A promise object with the result\r\n */\r\nexport const getJsonPromise = (url) => {\r\n    let request = new GET(\"JSON\").from(url);\r\n\r\n    return request.send();\r\n};\r\n\r\n\r\n","/*!\r\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\r\n * http://github.com/janl/mustache.js\r\n */\r\n\r\nvar objectToString = Object.prototype.toString;\r\nvar isArray = Array.isArray || function isArrayPolyfill (object) {\r\n  return objectToString.call(object) === '[object Array]';\r\n};\r\n\r\nfunction isFunction (object) {\r\n  return typeof object === 'function';\r\n}\r\n\r\n/**\r\n * More correct typeof string handling array\r\n * which normally returns typeof 'object'\r\n */\r\nfunction typeStr (obj) {\r\n  return isArray(obj) ? 'array' : typeof obj;\r\n}\r\n\r\nfunction escapeRegExp (string) {\r\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\r\n}\r\n\r\n/**\r\n * Null safe way of checking whether or not an object,\r\n * including its prototype, has a given property\r\n */\r\nfunction hasProperty (obj, propName) {\r\n  return obj != null && typeof obj === 'object' && (propName in obj);\r\n}\r\n\r\n/**\r\n * Safe way of detecting whether or not the given thing is a primitive and\r\n * whether it has the given property\r\n */\r\nfunction primitiveHasOwnProperty (primitive, propName) {\r\n  return (\r\n    primitive != null\r\n    && typeof primitive !== 'object'\r\n    && primitive.hasOwnProperty\r\n    && primitive.hasOwnProperty(propName)\r\n  );\r\n}\r\n\r\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\r\n// See https://github.com/janl/mustache.js/issues/189\r\nvar regExpTest = RegExp.prototype.test;\r\nfunction testRegExp (re, string) {\r\n  return regExpTest.call(re, string);\r\n}\r\n\r\nvar nonSpaceRe = /\\S/;\r\nfunction isWhitespace (string) {\r\n  return !testRegExp(nonSpaceRe, string);\r\n}\r\n\r\nvar entityMap = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;',\r\n  '\"': '&quot;',\r\n  \"'\": '&#39;',\r\n  '/': '&#x2F;',\r\n  '`': '&#x60;',\r\n  '=': '&#x3D;'\r\n};\r\n\r\nfunction escapeHtml (string) {\r\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\r\n    return entityMap[s];\r\n  });\r\n}\r\n\r\nvar whiteRe = /\\s*/;\r\nvar spaceRe = /\\s+/;\r\nvar equalsRe = /\\s*=/;\r\nvar curlyRe = /\\s*\\}/;\r\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\r\n\r\n/**\r\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\r\n * argument is given here it must be an array with two string values: the\r\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\r\n * course, the default is to use mustaches (i.e. mustache.tags).\r\n *\r\n * A token is an array with at least 4 elements. The first element is the\r\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\r\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\r\n * all text that appears outside a symbol this element is \"text\".\r\n *\r\n * The second element of a token is its \"value\". For mustache tags this is\r\n * whatever else was inside the tag besides the opening symbol. For text tokens\r\n * this is the text itself.\r\n *\r\n * The third and fourth elements of the token are the start and end indices,\r\n * respectively, of the token in the original template.\r\n *\r\n * Tokens that are the root node of a subtree contain two more elements: 1) an\r\n * array of tokens in the subtree and 2) the index in the original template at\r\n * which the closing tag for that section begins.\r\n *\r\n * Tokens for partials also contain two more elements: 1) a string value of\r\n * indendation prior to that tag and 2) the index of that tag on that line -\r\n * eg a value of 2 indicates the partial is the third tag on this line.\r\n */\r\nfunction parseTemplate (template, tags) {\r\n  if (!template)\r\n    return [];\r\n  var lineHasNonSpace = false;\r\n  var sections = [];     // Stack to hold section tokens\r\n  var tokens = [];       // Buffer to hold the tokens\r\n  var spaces = [];       // Indices of whitespace tokens on the current line\r\n  var hasTag = false;    // Is there a {{tag}} on the current line?\r\n  var nonSpace = false;  // Is there a non-space char on the current line?\r\n  var indentation = '';  // Tracks indentation for tags that use it\r\n  var tagIndex = 0;      // Stores a count of number of tags encountered on a line\r\n\r\n  // Strips all whitespace tokens array for the current line\r\n  // if there was a {{#tag}} on it and otherwise only space.\r\n  function stripSpace () {\r\n    if (hasTag && !nonSpace) {\r\n      while (spaces.length)\r\n        delete tokens[spaces.pop()];\r\n    } else {\r\n      spaces = [];\r\n    }\r\n\r\n    hasTag = false;\r\n    nonSpace = false;\r\n  }\r\n\r\n  var openingTagRe, closingTagRe, closingCurlyRe;\r\n  function compileTags (tagsToCompile) {\r\n    if (typeof tagsToCompile === 'string')\r\n      tagsToCompile = tagsToCompile.split(spaceRe, 2);\r\n\r\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\r\n      throw new Error('Invalid tags: ' + tagsToCompile);\r\n\r\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\r\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\r\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\r\n  }\r\n\r\n  compileTags(tags || mustache.tags);\r\n\r\n  var scanner = new Scanner(template);\r\n\r\n  var start, type, value, chr, token, openSection;\r\n  while (!scanner.eos()) {\r\n    start = scanner.pos;\r\n\r\n    // Match any text between tags.\r\n    value = scanner.scanUntil(openingTagRe);\r\n\r\n    if (value) {\r\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\r\n        chr = value.charAt(i);\r\n\r\n        if (isWhitespace(chr)) {\r\n          spaces.push(tokens.length);\r\n          indentation += chr;\r\n        } else {\r\n          nonSpace = true;\r\n          lineHasNonSpace = true;\r\n          indentation += ' ';\r\n        }\r\n\r\n        tokens.push([ 'text', chr, start, start + 1 ]);\r\n        start += 1;\r\n\r\n        // Check for whitespace on the current line.\r\n        if (chr === '\\n') {\r\n          stripSpace();\r\n          indentation = '';\r\n          tagIndex = 0;\r\n          lineHasNonSpace = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Match the opening tag.\r\n    if (!scanner.scan(openingTagRe))\r\n      break;\r\n\r\n    hasTag = true;\r\n\r\n    // Get the tag type.\r\n    type = scanner.scan(tagRe) || 'name';\r\n    scanner.scan(whiteRe);\r\n\r\n    // Get the tag value.\r\n    if (type === '=') {\r\n      value = scanner.scanUntil(equalsRe);\r\n      scanner.scan(equalsRe);\r\n      scanner.scanUntil(closingTagRe);\r\n    } else if (type === '{') {\r\n      value = scanner.scanUntil(closingCurlyRe);\r\n      scanner.scan(curlyRe);\r\n      scanner.scanUntil(closingTagRe);\r\n      type = '&';\r\n    } else {\r\n      value = scanner.scanUntil(closingTagRe);\r\n    }\r\n\r\n    // Match the closing tag.\r\n    if (!scanner.scan(closingTagRe))\r\n      throw new Error('Unclosed tag at ' + scanner.pos);\r\n\r\n    if (type == '>') {\r\n      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\r\n    } else {\r\n      token = [ type, value, start, scanner.pos ];\r\n    }\r\n    tagIndex++;\r\n    tokens.push(token);\r\n\r\n    if (type === '#' || type === '^') {\r\n      sections.push(token);\r\n    } else if (type === '/') {\r\n      // Check section nesting.\r\n      openSection = sections.pop();\r\n\r\n      if (!openSection)\r\n        throw new Error('Unopened section \"' + value + '\" at ' + start);\r\n\r\n      if (openSection[1] !== value)\r\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\r\n    } else if (type === 'name' || type === '{' || type === '&') {\r\n      nonSpace = true;\r\n    } else if (type === '=') {\r\n      // Set the tags for the next time around.\r\n      compileTags(value);\r\n    }\r\n  }\r\n\r\n  stripSpace();\r\n\r\n  // Make sure there are no open sections when we're done.\r\n  openSection = sections.pop();\r\n\r\n  if (openSection)\r\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\r\n\r\n  return nestTokens(squashTokens(tokens));\r\n}\r\n\r\n/**\r\n * Combines the values of consecutive text tokens in the given `tokens` array\r\n * to a single token.\r\n */\r\nfunction squashTokens (tokens) {\r\n  var squashedTokens = [];\r\n\r\n  var token, lastToken;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    token = tokens[i];\r\n\r\n    if (token) {\r\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\r\n        lastToken[1] += token[1];\r\n        lastToken[3] = token[3];\r\n      } else {\r\n        squashedTokens.push(token);\r\n        lastToken = token;\r\n      }\r\n    }\r\n  }\r\n\r\n  return squashedTokens;\r\n}\r\n\r\n/**\r\n * Forms the given array of `tokens` into a nested tree structure where\r\n * tokens that represent a section have two additional items: 1) an array of\r\n * all tokens that appear in that section and 2) the index in the original\r\n * template that represents the end of that section.\r\n */\r\nfunction nestTokens (tokens) {\r\n  var nestedTokens = [];\r\n  var collector = nestedTokens;\r\n  var sections = [];\r\n\r\n  var token, section;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    token = tokens[i];\r\n\r\n    switch (token[0]) {\r\n      case '#':\r\n      case '^':\r\n        collector.push(token);\r\n        sections.push(token);\r\n        collector = token[4] = [];\r\n        break;\r\n      case '/':\r\n        section = sections.pop();\r\n        section[5] = token[2];\r\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\r\n        break;\r\n      default:\r\n        collector.push(token);\r\n    }\r\n  }\r\n\r\n  return nestedTokens;\r\n}\r\n\r\n/**\r\n * A simple string scanner that is used by the template parser to find\r\n * tokens in template strings.\r\n */\r\nfunction Scanner (string) {\r\n  this.string = string;\r\n  this.tail = string;\r\n  this.pos = 0;\r\n}\r\n\r\n/**\r\n * Returns `true` if the tail is empty (end of string).\r\n */\r\nScanner.prototype.eos = function eos () {\r\n  return this.tail === '';\r\n};\r\n\r\n/**\r\n * Tries to match the given regular expression at the current position.\r\n * Returns the matched text if it can match, the empty string otherwise.\r\n */\r\nScanner.prototype.scan = function scan (re) {\r\n  var match = this.tail.match(re);\r\n\r\n  if (!match || match.index !== 0)\r\n    return '';\r\n\r\n  var string = match[0];\r\n\r\n  this.tail = this.tail.substring(string.length);\r\n  this.pos += string.length;\r\n\r\n  return string;\r\n};\r\n\r\n/**\r\n * Skips all text until the given regular expression can be matched. Returns\r\n * the skipped string, which is the entire tail if no match can be made.\r\n */\r\nScanner.prototype.scanUntil = function scanUntil (re) {\r\n  var index = this.tail.search(re), match;\r\n\r\n  switch (index) {\r\n    case -1:\r\n      match = this.tail;\r\n      this.tail = '';\r\n      break;\r\n    case 0:\r\n      match = '';\r\n      break;\r\n    default:\r\n      match = this.tail.substring(0, index);\r\n      this.tail = this.tail.substring(index);\r\n  }\r\n\r\n  this.pos += match.length;\r\n\r\n  return match;\r\n};\r\n\r\n/**\r\n * Represents a rendering context by wrapping a view object and\r\n * maintaining a reference to the parent context.\r\n */\r\nfunction Context (view, parentContext) {\r\n  this.view = view;\r\n  this.cache = { '.': this.view };\r\n  this.parent = parentContext;\r\n}\r\n\r\n/**\r\n * Creates a new context using the given view with this context\r\n * as the parent.\r\n */\r\nContext.prototype.push = function push (view) {\r\n  return new Context(view, this);\r\n};\r\n\r\n/**\r\n * Returns the value of the given name in this context, traversing\r\n * up the context hierarchy if the value is absent in this context's view.\r\n */\r\nContext.prototype.lookup = function lookup (name) {\r\n  var cache = this.cache;\r\n\r\n  var value;\r\n  if (cache.hasOwnProperty(name)) {\r\n    value = cache[name];\r\n  } else {\r\n    var context = this, intermediateValue, names, index, lookupHit = false;\r\n\r\n    while (context) {\r\n      if (name.indexOf('.') > 0) {\r\n        intermediateValue = context.view;\r\n        names = name.split('.');\r\n        index = 0;\r\n\r\n        /**\r\n         * Using the dot notion path in `name`, we descend through the\r\n         * nested objects.\r\n         *\r\n         * To be certain that the lookup has been successful, we have to\r\n         * check if the last object in the path actually has the property\r\n         * we are looking for. We store the result in `lookupHit`.\r\n         *\r\n         * This is specially necessary for when the value has been set to\r\n         * `undefined` and we want to avoid looking up parent contexts.\r\n         *\r\n         * In the case where dot notation is used, we consider the lookup\r\n         * to be successful even if the last \"object\" in the path is\r\n         * not actually an object but a primitive (e.g., a string, or an\r\n         * integer), because it is sometimes useful to access a property\r\n         * of an autoboxed primitive, such as the length of a string.\r\n         **/\r\n        while (intermediateValue != null && index < names.length) {\r\n          if (index === names.length - 1)\r\n            lookupHit = (\r\n              hasProperty(intermediateValue, names[index])\r\n              || primitiveHasOwnProperty(intermediateValue, names[index])\r\n            );\r\n\r\n          intermediateValue = intermediateValue[names[index++]];\r\n        }\r\n      } else {\r\n        intermediateValue = context.view[name];\r\n\r\n        /**\r\n         * Only checking against `hasProperty`, which always returns `false` if\r\n         * `context.view` is not an object. Deliberately omitting the check\r\n         * against `primitiveHasOwnProperty` if dot notation is not used.\r\n         *\r\n         * Consider this example:\r\n         * ```\r\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\r\n         * ```\r\n         *\r\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\r\n         * in the dot notation case, then render call would return:\r\n         *\r\n         * \"The length of a football field is 9.\"\r\n         *\r\n         * rather than the expected:\r\n         *\r\n         * \"The length of a football field is 100 yards.\"\r\n         **/\r\n        lookupHit = hasProperty(context.view, name);\r\n      }\r\n\r\n      if (lookupHit) {\r\n        value = intermediateValue;\r\n        break;\r\n      }\r\n\r\n      context = context.parent;\r\n    }\r\n\r\n    cache[name] = value;\r\n  }\r\n\r\n  if (isFunction(value))\r\n    value = value.call(this.view);\r\n\r\n  return value;\r\n};\r\n\r\n/**\r\n * A Writer knows how to take a stream of tokens and render them to a\r\n * string, given a context. It also maintains a cache of templates to\r\n * avoid the need to parse the same template twice.\r\n */\r\nfunction Writer () {\r\n  this.templateCache = {\r\n    _cache: {},\r\n    set: function set (key, value) {\r\n      this._cache[key] = value;\r\n    },\r\n    get: function get (key) {\r\n      return this._cache[key];\r\n    },\r\n    clear: function clear () {\r\n      this._cache = {};\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Clears all cached templates in this writer.\r\n */\r\nWriter.prototype.clearCache = function clearCache () {\r\n  if (typeof this.templateCache !== 'undefined') {\r\n    this.templateCache.clear();\r\n  }\r\n};\r\n\r\n/**\r\n * Parses and caches the given `template` according to the given `tags` or\r\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\r\n * that is generated from the parse.\r\n */\r\nWriter.prototype.parse = function parse (template, tags) {\r\n  var cache = this.templateCache;\r\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\r\n  var isCacheEnabled = typeof cache !== 'undefined';\r\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\r\n\r\n  if (tokens == undefined) {\r\n    tokens = parseTemplate(template, tags);\r\n    isCacheEnabled && cache.set(cacheKey, tokens);\r\n  }\r\n  return tokens;\r\n};\r\n\r\n/**\r\n * High-level method that is used to render the given `template` with\r\n * the given `view`.\r\n *\r\n * The optional `partials` argument may be an object that contains the\r\n * names and templates of partials that are used in the template. It may\r\n * also be a function that is used to load partial templates on the fly\r\n * that takes a single argument: the name of the partial.\r\n *\r\n * If the optional `config` argument is given here, then it should be an\r\n * object with a `tags` attribute or an `escape` attribute or both.\r\n * If an array is passed, then it will be interpreted the same way as\r\n * a `tags` attribute on a `config` object.\r\n *\r\n * The `tags` attribute of a `config` object must be an array with two\r\n * string values: the opening and closing tags used in the template (e.g.\r\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\r\n *\r\n * The `escape` attribute of a `config` object must be a function which\r\n * accepts a string as input and outputs a safely escaped string.\r\n * If an `escape` function is not provided, then an HTML-safe string\r\n * escaping function is used as the default.\r\n */\r\nWriter.prototype.render = function render (template, view, partials, config) {\r\n  var tags = this.getConfigTags(config);\r\n  var tokens = this.parse(template, tags);\r\n  var context = (view instanceof Context) ? view : new Context(view, undefined);\r\n  return this.renderTokens(tokens, context, partials, template, config);\r\n};\r\n\r\n/**\r\n * Low-level method that renders the given array of `tokens` using\r\n * the given `context` and `partials`.\r\n *\r\n * Note: The `originalTemplate` is only ever used to extract the portion\r\n * of the original template that was contained in a higher-order section.\r\n * If the template doesn't use higher-order sections, this argument may\r\n * be omitted.\r\n */\r\nWriter.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {\r\n  var buffer = '';\r\n\r\n  var token, symbol, value;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    value = undefined;\r\n    token = tokens[i];\r\n    symbol = token[0];\r\n\r\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\r\n    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\r\n    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\r\n    else if (symbol === '&') value = this.unescapedValue(token, context);\r\n    else if (symbol === 'name') value = this.escapedValue(token, context, config);\r\n    else if (symbol === 'text') value = this.rawValue(token);\r\n\r\n    if (value !== undefined)\r\n      buffer += value;\r\n  }\r\n\r\n  return buffer;\r\n};\r\n\r\nWriter.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {\r\n  var self = this;\r\n  var buffer = '';\r\n  var value = context.lookup(token[1]);\r\n\r\n  // This function is used to render an arbitrary template\r\n  // in the current context by higher-order sections.\r\n  function subRender (template) {\r\n    return self.render(template, context, partials, config);\r\n  }\r\n\r\n  if (!value) return;\r\n\r\n  if (isArray(value)) {\r\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\r\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\r\n    }\r\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\r\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\r\n  } else if (isFunction(value)) {\r\n    if (typeof originalTemplate !== 'string')\r\n      throw new Error('Cannot use higher-order sections without the original template');\r\n\r\n    // Extract the portion of the original template that the section contains.\r\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\r\n\r\n    if (value != null)\r\n      buffer += value;\r\n  } else {\r\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\r\n  }\r\n  return buffer;\r\n};\r\n\r\nWriter.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {\r\n  var value = context.lookup(token[1]);\r\n\r\n  // Use JavaScript's definition of falsy. Include empty arrays.\r\n  // See https://github.com/janl/mustache.js/issues/186\r\n  if (!value || (isArray(value) && value.length === 0))\r\n    return this.renderTokens(token[4], context, partials, originalTemplate, config);\r\n};\r\n\r\nWriter.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\r\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\r\n  var partialByNl = partial.split('\\n');\r\n  for (var i = 0; i < partialByNl.length; i++) {\r\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\r\n      partialByNl[i] = filteredIndentation + partialByNl[i];\r\n    }\r\n  }\r\n  return partialByNl.join('\\n');\r\n};\r\n\r\nWriter.prototype.renderPartial = function renderPartial (token, context, partials, config) {\r\n  if (!partials) return;\r\n  var tags = this.getConfigTags(config);\r\n\r\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\r\n  if (value != null) {\r\n    var lineHasNonSpace = token[6];\r\n    var tagIndex = token[5];\r\n    var indentation = token[4];\r\n    var indentedValue = value;\r\n    if (tagIndex == 0 && indentation) {\r\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\r\n    }\r\n    var tokens = this.parse(indentedValue, tags);\r\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\r\n  }\r\n};\r\n\r\nWriter.prototype.unescapedValue = function unescapedValue (token, context) {\r\n  var value = context.lookup(token[1]);\r\n  if (value != null)\r\n    return value;\r\n};\r\n\r\nWriter.prototype.escapedValue = function escapedValue (token, context, config) {\r\n  var escape = this.getConfigEscape(config) || mustache.escape;\r\n  var value = context.lookup(token[1]);\r\n  if (value != null)\r\n    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\r\n};\r\n\r\nWriter.prototype.rawValue = function rawValue (token) {\r\n  return token[1];\r\n};\r\n\r\nWriter.prototype.getConfigTags = function getConfigTags (config) {\r\n  if (isArray(config)) {\r\n    return config;\r\n  }\r\n  else if (config && typeof config === 'object') {\r\n    return config.tags;\r\n  }\r\n  else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nWriter.prototype.getConfigEscape = function getConfigEscape (config) {\r\n  if (config && typeof config === 'object' && !isArray(config)) {\r\n    return config.escape;\r\n  }\r\n  else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nvar mustache = {\r\n  name: 'mustache.js',\r\n  version: '4.2.0',\r\n  tags: [ '{{', '}}' ],\r\n  clearCache: undefined,\r\n  escape: undefined,\r\n  parse: undefined,\r\n  render: undefined,\r\n  Scanner: undefined,\r\n  Context: undefined,\r\n  Writer: undefined,\r\n  /**\r\n   * Allows a user to override the default caching strategy, by providing an\r\n   * object with set, get and clear methods. This can also be used to disable\r\n   * the cache by setting it to the literal `undefined`.\r\n   */\r\n  set templateCache (cache) {\r\n    defaultWriter.templateCache = cache;\r\n  },\r\n  /**\r\n   * Gets the default or overridden caching object from the default writer.\r\n   */\r\n  get templateCache () {\r\n    return defaultWriter.templateCache;\r\n  }\r\n};\r\n\r\n// All high-level mustache.* functions use this writer.\r\nvar defaultWriter = new Writer();\r\n\r\n/**\r\n * Clears all cached templates in the default writer.\r\n */\r\nmustache.clearCache = function clearCache () {\r\n  return defaultWriter.clearCache();\r\n};\r\n\r\n/**\r\n * Parses and caches the given template in the default writer and returns the\r\n * array of tokens it contains. Doing this ahead of time avoids the need to\r\n * parse templates on the fly as they are rendered.\r\n */\r\nmustache.parse = function parse (template, tags) {\r\n  return defaultWriter.parse(template, tags);\r\n};\r\n\r\n/**\r\n * Renders the `template` with the given `view`, `partials`, and `config`\r\n * using the default writer.\r\n */\r\nmustache.render = function render (template, view, partials, config) {\r\n  if (typeof template !== 'string') {\r\n    throw new TypeError('Invalid template! Template should be a \"string\" ' +\r\n                        'but \"' + typeStr(template) + '\" was given as the first ' +\r\n                        'argument for mustache#render(template, view, partials)');\r\n  }\r\n\r\n  return defaultWriter.render(template, view, partials, config);\r\n};\r\n\r\n// Export the escaping function so that the user may override it.\r\n// See https://github.com/janl/mustache.js/issues/244\r\nmustache.escape = escapeHtml;\r\n\r\n// Export these mainly for testing, but also for advanced usage.\r\nmustache.Scanner = Scanner;\r\nmustache.Context = Context;\r\nmustache.Writer = Writer;\r\n\r\nexport default mustache;","import { getJsonPromise, getHtmlPromise } from './helper_ajax.js';\r\n\r\nimport Mustache from './libs/mustache.js';\r\n\r\n/**\r\n * - A class representing a template for rendering content onto the page. \r\n */\r\nexport class Template {\r\n    constructor(settings) {\r\n\r\n        if (typeof settings === \"object\") {\r\n            Object.assign(this, settings);\r\n        }\r\n\r\n        this.context = this.context || {};\r\n        this.html = this.html ?? \"\";\r\n        this.engine = this.engine ?? \"default\";\r\n        this.target = this.target ?? \"#NoTargetSelected\";\r\n        this.rendered = this.rendered ?? \"\";\r\n        this.dataUrl = this.dataUrl ?? null;\r\n        this.htmlUrl = this.htmlUrl ?? null;\r\n        this.autoRender = this.autoRender || false;\r\n\r\n        this.engines = {\r\n            default: () => {\r\n                return this.html;\r\n            },\r\n            mustache: () => {\r\n                return Mustache.render(this.html, this.context);\r\n            }\r\n        };\r\n\r\n        //let {prep_func: ()=>{ return (object, render)=>{//Code Here}}};\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {object} items - Merge items with context. For Mustache render helpers\r\n     * use this format: {prep_func: ()=>{ return (object, render)=>{//Code Here}}};\r\n     */\r\n    enhanceContext(items) {\r\n        Object.assign(this.context, items);\r\n    }\r\n\r\n    /**\r\n     * - Gets HTML from a URL and sets the html field. \r\n     * @param {string} url \r\n     * @param {boolean} noRender - flag to prevent unnecessary rendering\r\n     * @returns a promise object with the result. \r\n     */\r\n    async importPartial(url, noRender) {\r\n\r\n        const self = this;\r\n\r\n        url = url ?? self.htmlUrl;\r\n\r\n        try {\r\n            let result = await getHtmlPromise(url);\r\n            self.html = result;\r\n            if (self.autoRender && noRender != true) self.render(self.target);\r\n            return result;\r\n        }\r\n        catch (error) {\r\n            return error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * - Gets JSON from a URL and sets the context field. \r\n     * @param {string} url \r\n     * @param {boolean} noRender \r\n     * @returns A promise object with the result.\r\n     */\r\n    async importContext(url, noRender) {\r\n\r\n        const self = this;\r\n\r\n        url = url ?? self.dataUrl;\r\n\r\n        try {\r\n            let result = await getJsonPromise(url);\r\n            self.context = result;\r\n            if (self.autoRender && noRender != true) self.render(self.target);\r\n            return result;\r\n        }\r\n        catch (error) {\r\n            return error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * - Gets JSON/HTML from a URL and sets the context & html fields. \r\n     * @param {string} dataUrl - URL of JSON string\r\n     * @param {*} templateUrl - URL of HTML text\r\n     * @returns a promise object with a reference to the template. \r\n     */\r\n    async importPackage(dataUrl, templateUrl) {\r\n\r\n        let self = this;\r\n\r\n        dataUrl = dataUrl ?? self.dataUrl;\r\n        templateUrl = templateUrl ?? self.templateUrl;\r\n\r\n        await this.importPartial(templateUrl, true);\r\n\r\n        await this.importContext(dataUrl, true);\r\n\r\n        if (self.autoRender) self.render(self.target);\r\n\r\n        return self;\r\n    }\r\n\r\n    /**\r\n     * - Gets HTML from a template already on the page. Can render if the\r\n     * target is already set. \r\n     * @param {string} selector \r\n     * @returns a reference to the template instance for chaining. \r\n     */\r\n    load(selector) {\r\n        let template = document.querySelector(selector);\r\n\r\n        let engine = template.dataset.engine ?? \"default\";\r\n\r\n        this.html = template.innerHTML ?? \"<em>No Template Found</em>\";\r\n\r\n        this.engine = engine;\r\n\r\n        if (this.autoRender) this.render(this.target);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * - Renders the current template to the innerHTML of the element\r\n     * matching the provided selector. \r\n     * @param {string} selector \r\n     * @returns a reference to the tamplet instance for chaining. \r\n     */\r\n    render(selector) {\r\n\r\n        let target = document.querySelector(selector);\r\n\r\n        let rendered = this.engines[this.engine]?.();\r\n\r\n        this.rendered = rendered;\r\n\r\n        if (target?.innerHTML) {\r\n            target.innerHTML = rendered;\r\n        }\r\n\r\n        console.log(\"Rendered HTML to Page\")\r\n\r\n        return this.rendered;\r\n    }\r\n\r\n}","/**\r\n * Class representing a performance benchmark.\r\n */\r\nexport class Benchmark {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.start = performance.now();\r\n        this.result = 0;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns a completed benchmark\r\n     */\r\n    stop() {\r\n        this.result = performance.now() - this.start;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * verbose benchmark output\r\n     */\r\n    get detailedResults() {\r\n        return `Task \"${this.name}\" executed in ${this.result} ms.`;\r\n    }\r\n}","import { events } from './custom_events.js';\r\n\r\nimport { getHtmlPromise, getJsonPromise } from './helper_ajax.js';\r\n\r\nimport { Template } from './class_Template.js';\r\n\r\nimport { Modal } from './class_Modal.js';\r\n\r\nimport { Benchmark } from './class_Benchmark.js';\r\n\r\n\r\n/**\r\n * Here we add event listeners and setup the app. \r\n */\r\ndocument.body.addEventListener(\"keyup\", (e) => {\r\n\r\n    let source = e.target;\r\n\r\n    events.keyup[source.dataset.keyup]?.(source, e);\r\n});\r\n\r\ndocument.body.addEventListener(\"change\", (e) => {\r\n\r\n    let source = e.target;\r\n\r\n    events.change[source.dataset.change]?.(source, e);\r\n});\r\n\r\ndocument.body.addEventListener(\"click\", (e) => {\r\n\r\n    let source = e.target;\r\n\r\n    events.click[source.dataset.click]?.(source, e);\r\n});\r\n\r\ndocument.body.onload = () => {\r\n\r\n    // Example: Setup a template where the data AND template need to be downladed. \r\n    // In this example, are only do 1 function call and everything else is in the settings. \r\n    // You could leave the settings blank & setup everything with functions as well. \r\n\r\n    let foo = new Template({\r\n        engine: \"mustache\",\r\n        autoRender: true,\r\n        dataUrl: \"api/test.json\",\r\n        htmlUrl: \"api/partial.html\",\r\n        target: \"#TestArea\"\r\n    });\r\n\r\n    // importPackage returns a promise so we can use the standard then/catch syntax if we want.\r\n    foo.importPackage().catch((error) => {\r\n        console.log(error);\r\n    });\r\n\r\n    // Let's get some data asynchronously and log it\r\n    getJsonPromise(\"api/test.json\")\r\n        .then((result) => {\r\n            console.log(`We got this text: ${result.someText}`);\r\n        }).catch((error) => {\r\n            console.log(error);\r\n        });\r\n\r\n    // Let's use an async function to get some HTML data\r\n    // Then let's pop it up on a modal window. \r\n    async function sayHello() {\r\n        try {\r\n            let url = \"api/greeting.html\";\r\n            let result = await getHtmlPromise(url);\r\n            let message = new Modal(result);\r\n            message.show();\r\n        }\r\n        catch (error) {\r\n            console.log(error);\r\n        }\r\n    }\r\n\r\n    // This function is the SAME as the one above except it doesn't use\r\n    // the async/await syntax and it uses then/catch chaining instead. \r\n    // Otherwise they're IDENTICAL. Just FYI. \r\n    function sayHi() {\r\n        let url = \"api/greeting.html\";\r\n        getHtmlPromise(url)\r\n            .then((result) => {\r\n                let message = new Modal(result);\r\n                message.show();\r\n            }).catch((error) => {\r\n                console.log(error);\r\n            });\r\n    }\r\n\r\n    // Let's stick this in the click events so it only happens when you click a button. \r\n    // Normally I wouldn't set events here, just define them in custom_events.js\r\n    events.click.hello = sayHello;\r\n\r\n    // For fun, let's do an async operation and then calculate how long it took: \r\n    async function doStuff(url){\r\n        let result = await getJsonPromise(`api/test.json?_=${Math.random()}`);\r\n        console.log(result);\r\n    }\r\n\r\n    // Start the timer\r\n    let test = new Benchmark(\"Doing Stuff\");\r\n    doStuff().then(()=>{\r\n        test.stop(); //Aaaaand TIME!\r\n        console.log(test.detailedResults)\r\n    });\r\n\r\n};\r\n\r\n"],"names":["$be89b273d21c17493d5a78b70df85a47$export$b3e36f066d3bceb9","this","element","remove","modalContent","content","innerHTML","body","appendChild","template","show","callbacks","confirmYes","close","ifYes","confirmNo","ifNo","callback","call","e","target","text","document","createElement","$5c76a0f53be8807bfc0cd04447259a76$export$fc4ac6ce2f1d593c","click","change","keyup","actions","$a0de3fd8567797742aadc5e19611a249$export$e7f8695b207ce249","[object Object]","url","from","data","returnType","JSON","parse","requestType","xhr","setRequestHeader","keys","map","key","str","_prepHeaders","Promise","resolve","reject","Request1","status","_processReturn","response","onerror","$23409598976c046a08dd29616b5fa04d$export$bb7e79c84dee9e44","$a0de3fd8567797742aadc5e19611a249$export$ae4f7751a06ad53d","send","$23409598976c046a08dd29616b5fa04d$export$4aa02d87adfb76de","Array","isArray","object","isFunction","escapeRegExp","string","replace","hasProperty","obj","propName","RegExp","prototype","test","re","regExpTest","testRegExp","nonSpaceRe",">","\"","'","/","`","=","curlyRe","tagRe","Scanner","Context","view","parentContext","cache",".","parent","Writer","templateCache","_cache","value","tail","match","index","length","search","substring","hasOwnProperty","name","intermediateValue","names","context","lookupHit","indexOf","split","primitive","clearCache","clear","tags","cacheKey","mustache","join","isCacheEnabled","tokens","get","undefined","closingTagRe","closingCurlyRe","stripSpace","hasTag","nonSpace","spaces","pop","tagsToCompile","Error","type","chr","token","openSection","scanner","eos","pos","scanUntil","openingTagRe","i","valueLength","isWhitespace","charAt","push","indentation","lineHasNonSpace","start","scan","whiteRe","equalsRe","tagIndex","sections","collector","nestedTokens","lastToken","numTokens","squashedTokens","parseTemplate","set","String","s","entityMap","$fed7d5c0654d3f55ce1f35e829bea183$export$93af88fe68eea917","items","Object","assign","noRender","result","self","html","error","dataUrl","templateUrl","importPartial","importContext","autoRender","render","selector","querySelector","_engine","dataset","engine","_innerHTML","engines","rendered","$a1af1243bb1790146e1d5f75385f6b2b$export$ccc769439d8c8491","performance","now","addEventListener","ref","source","_keyup","_change","_click","onload","console","log","then","someText","hello"],"version":3,"file":"index.8dc764a1.js.map"}